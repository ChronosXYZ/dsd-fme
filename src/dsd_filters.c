// DMR filter
#define NZEROS 60
float ngain = 7.423339364f;
static float xv[NZEROS+1];
float xcoeffs[] =
{ -0.0083649323f, -0.0265444850f, -0.0428141462f, -0.0537571943f,
-0.0564141052f, -0.0489161045f, -0.0310068662f, -0.0043393881f,
+0.0275375106f, +0.0595423283f, +0.0857543325f, +0.1003565948f,
+0.0986944931f, +0.0782804830f, +0.0395670487f, -0.0136691535f,
-0.0744390415f, -0.1331834575f, -0.1788967208f, -0.2005995448f,
-0.1889627181f, -0.1378439993f, -0.0454976231f, +0.0847488694f,
+0.2444859269f, +0.4209222342f, +0.5982295474f, +0.7593684540f,
+0.8881539892f, +0.9712773915f, +0.9999999166f, +0.9712773915f,
+0.8881539892f, +0.7593684540f, +0.5982295474f, +0.4209222342f,
+0.2444859269f, +0.0847488694f, -0.0454976231f, -0.1378439993f,
-0.1889627181f, -0.2005995448f, -0.1788967208f, -0.1331834575f,
-0.0744390415f, -0.0136691535f, +0.0395670487f, +0.0782804830f,
+0.0986944931f, +0.1003565948f, +0.0857543325f, +0.0595423283f,
+0.0275375106f, -0.0043393881f, -0.0310068662f, -0.0489161045f,
-0.0564141052f, -0.0537571943f, -0.0428141462f, -0.0265444850f,
-0.0083649323f,
};

// NXDN48 filter
//#define NXZEROS 134
//float nxgain = 15.95930463f; 

#define NXZEROS 91 //Osmocom OP25
float nxgain = 1.0f; //Osmocom OP25

static float nxv[NXZEROS+1];

//OP25 Osmocom NXDN48 Coeffs seem to do well, will want to do some VS testing
float nxcoeffs[] =
{ 0.00203767f,  0.00491622f,  0.00748189f,  0.00934561f,  0.01017049f,  0.00972167f,
  0.00790748f,  0.00480597f,  0.00067202f, -0.00407743f, -0.00890019f, -0.01318478f,
 -0.01632047f, -0.01777371f, -0.01716241f, -0.01431852f, -0.00933066f, -0.00255979f,
  0.00537624f,  0.01364992f,  0.02130038f,  0.02733235f,  0.03082824f,  0.03106179f,
  0.02760061f,  0.02038545f,  0.00977572f, -0.0034462f,  -0.01811514f, -0.03276675f,
 -0.04575844f, -0.05541762f, -0.06020353f, -0.0588669f,  -0.05059129f, -0.03510097f,
 -0.01272309f,  0.01560398f,  0.04837926f,  0.08364189f,  0.11912012f,  0.15241359f,
  0.18119246f,  0.20339503f,  0.21740525f,  0.2221932f,   0.21740525f,  0.20339503f,
  0.18119246f,  0.15241359f,  0.11912012f,  0.08364189f,  0.04837926f,  0.01560398f,
 -0.01272309f, -0.03510097f, -0.05059129f, -0.0588669f,  -0.06020353f, -0.05541762f,
 -0.04575844f, -0.03276675f, -0.01811514f, -0.0034462f,   0.00977572f,  0.02038545f,
  0.02760061f,  0.03106179f,  0.03082824f,  0.02733235f,  0.02130038f,  0.01364992f,
  0.00537624f, -0.00255979f, -0.00933066f, -0.01431852f, -0.01716241f, -0.01777371f,
 -0.01632047f, -0.01318478f, -0.00890019f, -0.00407743f,  0.00067202f,  0.00480597f,
  0.00790748f,  0.00972167f,  0.01017049f,  0.00934561f,  0.00748189f,  0.00491622f,
  0.00203767f};

//OLD nxCOEFFS
// { +0.031462429f, +0.031747267f, +0.030401148f, +0.027362877f,
// +0.022653298f, +0.016379869f, +0.008737200f, +0.000003302f,
// -0.009468531f, -0.019262057f, -0.028914291f, -0.037935027f,
// -0.045828927f, -0.052119261f, -0.056372283f, -0.058221106f,
// -0.057387924f, -0.053703443f, -0.047122444f, -0.037734535f,
// -0.025769308f, -0.011595336f, +0.004287292f, +0.021260954f,
// +0.038610717f, +0.055550276f, +0.071252765f, +0.084885375f,
// +0.095646450f, +0.102803611f, +0.105731303f, +0.103946126f,
// +0.097138329f, +0.085197939f, +0.068234131f, +0.046586711f,
// +0.020828821f, -0.008239664f, -0.039608255f, -0.072081234f,
// -0.104311776f, -0.134843790f, -0.162160200f, -0.184736015f,
// -0.201094346f, -0.209863285f, -0.209831516f, -0.200000470f,
// -0.179630919f, -0.148282051f, -0.105841323f, -0.052543664f,
// +0.011020985f, +0.083912428f, +0.164857408f, +0.252278939f,
// +0.344336996f, +0.438979335f, +0.534000832f, +0.627109358f,
// +0.715995947f, +0.798406824f, +0.872214756f, +0.935487176f,
// +0.986548646f, +1.024035395f, +1.046939951f, +1.054644241f,
// +1.046939951f, +1.024035395f, +0.986548646f, +0.935487176f,
// +0.872214756f, +0.798406824f, +0.715995947f, +0.627109358f,
// +0.534000832f, +0.438979335f, +0.344336996f, +0.252278939f,
// +0.164857408f, +0.083912428f, +0.011020985f, -0.052543664f,
// -0.105841323f, -0.148282051f, -0.179630919f, -0.200000470f,
// -0.209831516f, -0.209863285f, -0.201094346f, -0.184736015f,
// -0.162160200f, -0.134843790f, -0.104311776f, -0.072081234f,
// -0.039608255f, -0.008239664f, +0.020828821f, +0.046586711f,
// +0.068234131f, +0.085197939f, +0.097138329f, +0.103946126f,
// +0.105731303f, +0.102803611f, +0.095646450f, +0.084885375f,
// +0.071252765f, +0.055550276f, +0.038610717f, +0.021260954f,
// +0.004287292f, -0.011595336f, -0.025769308f, -0.037734535f,
// -0.047122444f, -0.053703443f, -0.057387924f, -0.058221106f,
// -0.056372283f, -0.052119261f, -0.045828927f, -0.037935027f,
// -0.028914291f, -0.019262057f, -0.009468531f, +0.000003302f,
// +0.008737200f, +0.016379869f, +0.022653298f, +0.027362877f,
// +0.030401148f, +0.031747267f, +0.031462429f,
// };

// DMR filter F4EXB
#define DMRNZEROS 60

// DMR filter F4EXB
const float dmrgain = 6.82973073748f;

// DMR filter F4EXB
static float dxv[DMRNZEROS+1];

// DMR filter F4EXB - root raised cosine alpha=0.7 Ts = 6650 S/s Fc = 48kHz
const float dmrcoeffs[] =
{0.0301506278, 0.0269200615, 0.0159662432, -0.0013114705, -0.0216605133, 
-0.0404938748, -0.0528141756, -0.0543747957, -0.0428325003, -0.0186176083, 
0.0147202645, 0.0508418571, 0.0816392577, 0.0988113688, 0.0957187780, 
0.0691512084, 0.0206194642, -0.0431564563, -0.1107569268, -0.1675773224, 
-0.1981519842, -0.1889130786, -0.1308939560, -0.0218608492, 0.1325685970, 
0.3190962499, 0.5182530574, 0.7070497652, 0.8623526878, 0.9644213921, 
1.0000000000, 0.9644213921, 0.8623526878, 0.7070497652, 0.5182530574, 
0.3190962499, 0.1325685970, -0.0218608492, -0.1308939560, -0.1889130786, 
-0.1981519842, -0.1675773224, -0.1107569268, -0.0431564563, 0.0206194642, 
0.0691512084, 0.0957187780, 0.0988113688, 0.0816392577, 0.0508418571, 
0.0147202645, -0.0186176083, -0.0428325003, -0.0543747957, -0.0528141756, 
-0.0404938748, -0.0216605133, -0.0013114705, 0.0159662432, 0.0269200615, 0.0301506278};



short dsd_input_filter(short sample, int mode);

short
dmr_filter(short sample)
{
    return dsd_input_filter(sample, 3);
}

short
nxdn_filter(short sample)
{
    return dsd_input_filter(sample, 2);
}


short
dsd_input_filter(short sample, int mode)
{
  float sum; int i;
  float gain;
  int zeros;
  float *v, *coeffs;
  switch(mode) {
    case 1:
      gain = ngain;
      v = xv;
      coeffs = xcoeffs;
      zeros = NZEROS;
      break;
    case 2:
      gain = nxgain;
      v = nxv;
      coeffs = nxcoeffs;
      zeros = NXZEROS;
      break;
    case 3:
        gain = dmrgain;
        v = dxv;
        coeffs = (float *)dmrcoeffs;
        zeros = DMRNZEROS;
        break;
    default:
      return sample;
  }
  
  for (i = 0; i < zeros; i++)
      v[i] = v[i+1];

  v[zeros] = sample; // unfiltered sample in
  sum = 0.0f;

  for (i = 0; i <= zeros; i++)
    sum += (coeffs[i] * v[i]);

  return (short)(sum / gain); // filtered sample out
}