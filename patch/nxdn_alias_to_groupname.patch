diff --git a/src/dsd_ncurses.c b/src/dsd_ncurses.c
index 501124e..e2939e4 100644
--- a/src/dsd_ncurses.c
+++ b/src/dsd_ncurses.c
@@ -2754,6 +2754,8 @@ ncursesPrinter (dsd_opts * opts, dsd_state * state)
     printw ("| ");
     printw ("TGT: [%5d] ", tgn);
     printw ("SRC: [%5d] ", src);
+
+    #ifdef LIMAZULUTWEAKS
     if (state->nxdn_alias_block_segment[0][0] > 0) 
     {
       printw ("ALIAS: [");
@@ -2764,23 +2766,30 @@ ncursesPrinter (dsd_opts * opts, dsd_state * state)
           printw ("%s", state->nxdn_alias_block_segment[i][j]); 
         }
       }
-      printw ("]");
+      printw ("] ");
     }
+    #endif
 
     //Group Name Labels from CSV import
     for (int k = 0; k < state->group_tally; k++)
     {
       if (state->group_array[k].groupNumber == tgn)
       {
+        printw ("TG: ");
         attron(COLOR_PAIR(4));
-        printw (" [%s]", state->group_array[k].groupName);
+        printw ("[%s]", state->group_array[k].groupName);
         printw ("[%s] ", state->group_array[k].groupMode);
       }
       else if (state->group_array[k].groupNumber == src)
       {
+        #ifdef LIMAZULUTWEAKS
+        ; //skip Alias Line
+        #else
+        printw ("ALIAS: ");
+        #endif
         attron(COLOR_PAIR(4));
-        printw (" [%s]", state->group_array[k].groupName);
-        printw ("[%s] ", state->group_array[k].groupMode);
+        printw ("%s", state->group_array[k].groupName);
+        // printw ("[%s] ", state->group_array[k].groupMode);
       }
       if (state->carrier == 1)
       {
diff --git a/src/nxdn_element.c b/src/nxdn_element.c
index 8907cab..c8c9b30 100644
--- a/src/nxdn_element.c
+++ b/src/nxdn_element.c
@@ -732,6 +732,63 @@ void NXDN_decode_Alias(dsd_opts * opts, dsd_state * state, uint8_t * Message)
 
     if (Alias4 > 0x19 && Alias4 < 0x7F) sprintf (state->nxdn_alias_block_segment[blocknumber-1][3], "%c", Alias4);
     //else sprintf (state->nxdn_alias_block_segment[blocknumber-1][3], "%c", 0); //space
+
+    //TEST: Assign to call history (if not already in groupName)
+    char str_a[120]; char str_b[50]; int wr = 0; int tsrc = state->nxdn_last_rid; int z = 0;
+    sprintf (str_a, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+      state->nxdn_alias_block_segment[0][0], state->nxdn_alias_block_segment[0][1], state->nxdn_alias_block_segment[0][2], state->nxdn_alias_block_segment[0][3],
+      state->nxdn_alias_block_segment[1][0], state->nxdn_alias_block_segment[1][1], state->nxdn_alias_block_segment[1][2], state->nxdn_alias_block_segment[1][3],
+      state->nxdn_alias_block_segment[2][0], state->nxdn_alias_block_segment[2][1], state->nxdn_alias_block_segment[2][2], state->nxdn_alias_block_segment[2][3],
+      state->nxdn_alias_block_segment[3][0], state->nxdn_alias_block_segment[3][1], state->nxdn_alias_block_segment[3][2], state->nxdn_alias_block_segment[3][3]);
+
+    #ifdef LIMAZULUTWEAKS //disable saving the alias to call history/groupName and potentially overwriting any imported src names in the array
+    UNUSED(z); UNUSED(tsrc); UNUSED(wr); UNUSED(str_b); UNUSED(str_a);
+    #else
+
+    //juggle strings here so we don't get compiler warnings on assignment size
+    memcpy (str_b, str_a, 48); str_b[49] = '\0';
+
+    if (tsrc != 0)
+    {
+      for (int x = 0; x < state->group_tally; x++)
+      {
+        if (state->group_array[x].groupNumber == tsrc)
+        {
+          wr = 1; //already in there, so no need to assign it
+          z = x;
+          break;
+        }
+      }
+
+      //NOTE: Assigning D or DE here could still clash with ENC LO and also normal A/B/D/DE from group import
+      //among other issues, so, will need to evaluate and tweak, or stash in the eternal stash of ideas to revisit
+
+      //if not already in there, so save it there now (find clever way to use this and also ENC LO)
+      if (wr == 0)
+      {
+        state->group_array[state->group_tally].groupNumber = tsrc;
+        if (state->nxdn_cipher_type != 0 && opts->trunk_tune_enc_calls == 0 && state->R == 0)
+          sprintf (state->group_array[state->group_tally].groupMode, "%s", "DE");
+        else
+          sprintf (state->group_array[state->group_tally].groupMode, "%s", "D"); //could still override a blocked TG, or vice versa
+        sprintf (state->group_array[state->group_tally].groupName, "%s", str_b);
+        state->group_tally++;
+      }
+
+      //if its in there, but doesn't match (bad/partial decode) -- the mode checks are to help limit overwriting imported src names as long as they don't use the D or DE values
+      else if ( (strcmp(str_b, state->group_array[z].groupName) != 0) && (strcmp("B", state->group_array[z].groupMode) != 0) && (strcmp("A", state->group_array[z].groupMode) != 0) )
+      {
+        state->group_array[z].groupNumber = tsrc;
+        if (state->nxdn_cipher_type != 0 && opts->trunk_tune_enc_calls == 0 && state->R == 0)
+          sprintf (state->group_array[z].groupMode, "%s", "DE"); //having this here will allow a later lockout to occur if required
+        else
+          sprintf (state->group_array[z].groupMode, "%s", "D");
+        sprintf (state->group_array[z].groupName, "%s", str_b);
+      }
+    }
+
+    #endif
+
   }
 
   //crc errs in one repitition may occlude an otherwise good alias, so test and change if needed
